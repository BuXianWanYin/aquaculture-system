# 前后端代码联动说明文档

## 一、概述

本文档详细说明水产养殖管理系统中前后端代码的联动机制，包括 API 接口对接、数据格式、权限控制、错误处理等方面的实现细节。

---

## 二、架构设计

### 2.1 整体架构

```
┌─────────────────────────────────────────────────┐
│                   前端 (Vue 3)                   │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐     │
│  │  视图层   │→ │ API 层   │→ │ 工具层   │     │
│  │  (Views) │  │  (API)   │  │ (Utils)  │     │
│  └──────────┘  └──────────┘  └──────────┘     │
│                       ↓ HTTP/REST               │
└─────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────┐
│                后端 (Spring Boot)                │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐     │
│  │控制器层   │→ │ 服务层   │→ │ 数据层   │     │
│  │(Controller│  │(Service)│  │ (Mapper) │     │
│  └──────────┘  └──────────┘  └──────────┘     │
└─────────────────────────────────────────────────┘
```

### 2.2 通信方式

- **协议**: HTTP/HTTPS
- **数据格式**: JSON
- **认证方式**: JWT Token (Bearer Token)
- **跨域处理**: 开发环境使用代理，生产环境配置 CORS

---

## 三、API 接口对接

### 3.1 基础 URL 配置

#### 前端配置 (vite.config.js)

```javascript
server: {
  port: 3000,
  proxy: {
    '/api': {
      target: 'http://localhost:8080',
      changeOrigin: true
    },
    '/uploads': {
      target: 'http://localhost:8080',
      changeOrigin: true
    }
  }
}
```

#### 后端配置 (application.yml)

```yaml
server:
  port: 8080
```

**说明**:
- 前端开发服务器运行在 `http://localhost:3000`
- 后端服务运行在 `http://localhost:8080`
- 前端通过 Vite 代理将 `/api` 请求转发到后端
- 文件上传路径 `/uploads` 也通过代理转发

### 3.2 请求封装

#### 前端请求封装 (utils/request.js)

```javascript
import axios from 'axios'
import { ElMessage } from 'element-plus'
import router from '@/router'

const request = axios.create({
  baseURL: '/api',        // API 基础路径
  timeout: 10000          // 请求超时时间（10秒）
})

// 请求拦截器：自动添加 Token
request.interceptors.request.use(
  config => {
    const token = localStorage.getItem('token')
    if (token) {
      config.headers.Authorization = `Bearer ${token}`
    }
    return config
  },
  error => {
    return Promise.reject(error)
  }
)

// 响应拦截器：统一处理响应和错误
request.interceptors.response.use(
  response => {
    const res = response.data
    if (res.code === 200) {
      return res
    } else {
      ElMessage.error(res.message || '请求失败')
      return Promise.reject(new Error(res.message || '请求失败'))
    }
  },
  error => {
    // 处理 HTTP 错误状态码
    if (error.response) {
      switch (error.response.status) {
        case 401:
          ElMessage.error('未授权，请重新登录')
          localStorage.removeItem('token')
          router.push('/login')
          break
        case 403:
          ElMessage.error('拒绝访问')
          break
        case 404:
          ElMessage.error('请求错误，未找到该资源')
          break
        case 500:
          ElMessage.error('服务器错误')
          break
        default:
          ElMessage.error(error.response.data?.message || '网络错误')
      }
    } else {
      ElMessage.error('网络连接失败')
    }
    return Promise.reject(error)
  }
)

export default request
```

#### 后端统一响应格式 (common/Result.java)

```java
@Data
public class Result<T> {
    private Integer code;      // 响应码：200 表示成功，其他表示失败
    private String message;     // 响应消息
    private T data;            // 响应数据
    
    public static <T> Result<T> success(T data) {
        Result<T> result = new Result<>();
        result.setCode(200);
        result.setMessage("操作成功");
        result.setData(data);
        return result;
    }
    
    public static <T> Result<T> error(String message) {
        Result<T> result = new Result<>();
        result.setCode(500);
        result.setMessage(message);
        return result;
    }
}
```

### 3.3 API 接口示例

#### 用户登录接口

**后端接口** (`SysUserController.java`):

```java
@PostMapping("/login")
public Result<UserDTO> login(@RequestBody LoginDTO loginDTO, HttpServletRequest request) {
    try {
        UserDTO userDTO = userService.login(loginDTO);
        return Result.success("登录成功", userDTO);
    } catch (Exception e) {
        return Result.error(e.getMessage());
    }
}
```

**前端调用** (`api/user.js`):

```javascript
export const login = (data) => {
  return request({
    url: '/user/login',
    method: 'post',
    data
  })
}
```

**前端使用** (`views/Login.vue` 或 `stores/user.js`):

```javascript
import { login } from '@/api/user'

const res = await login({ username: 'admin', password: '123456' })
if (res.code === 200) {
  // 登录成功
  const token = res.data.token
  localStorage.setItem('token', token)
  // 保存用户信息
  localStorage.setItem('userInfo', JSON.stringify(res.data))
}
```

**请求示例**:

```http
POST /api/user/login HTTP/1.1
Content-Type: application/json

{
  "username": "admin",
  "password": "123456"
}
```

**响应示例**:

```json
{
  "code": 200,
  "message": "登录成功",
  "data": {
    "userId": 1,
    "username": "admin",
    "realName": "管理员",
    "roleId": 1,
    "roleName": "系统管理员",
    "token": "eyJhbGciOiJIUzUxMiJ9...",
    "permissions": ["system:user:view", "system:user:add", ...]
  }
}
```

#### 分页查询接口

**后端接口** (`SysUserController.java`):

```java
@GetMapping("/page")
@RequiresPermission({"system:user:view"})
public Result<Page<SysUser>> getPage(
        @RequestParam(defaultValue = "1") Integer current,
        @RequestParam(defaultValue = "10") Integer size,
        @RequestParam(required = false) String username,
        @RequestParam(required = false) Long roleId) {
    Page<SysUser> page = userService.getPage(current, size, username, roleId);
    return Result.success(page);
}
```

**前端调用** (`api/user.js`):

```javascript
export const getUserList = (params) => {
  return request({
    url: '/user/page',
    method: 'get',
    params
  })
}
```

**前端使用**:

```javascript
import { getUserList } from '@/api/user'

const params = {
  current: 1,
  size: 10,
  username: 'admin',
  roleId: 1
}
const res = await getUserList(params)
if (res.code === 200) {
  const pageData = res.data
  console.log(pageData.records)    // 数据列表
  console.log(pageData.total)      // 总记录数
  console.log(pageData.current)    // 当前页
  console.log(pageData.size)       // 每页大小
}
```

**请求示例**:

```http
GET /api/user/page?current=1&size=10&username=admin&roleId=1 HTTP/1.1
Authorization: Bearer eyJhbGciOiJIUzUxMiJ9...
```

**响应示例**:

```json
{
  "code": 200,
  "message": "操作成功",
  "data": {
    "records": [
      {
        "userId": 1,
        "username": "admin",
        "realName": "管理员",
        "roleId": 1,
        "status": 1
      }
    ],
    "total": 100,
    "current": 1,
    "size": 10,
    "pages": 10
  }
}
```

---

## 四、JWT Token 认证联动

### 4.1 Token 生成（后端）

**后端生成 Token** (`utils/JwtUtil.java`):

```java
public static String generateToken(Long userId, Long roleId) {
    return Jwts.builder()
        .setSubject(userId.toString())
        .claim("roleId", roleId)
        .setExpiration(new Date(System.currentTimeMillis() + EXPIRATION))
        .signWith(SignatureAlgorithm.HS512, SECRET)
        .compact();
}
```

**登录接口返回 Token** (`SysUserController.java`):

```java
@PostMapping("/login")
public Result<UserDTO> login(@RequestBody LoginDTO loginDTO) {
    UserDTO userDTO = userService.login(loginDTO);
    // userDTO 中包含 token
    return Result.success("登录成功", userDTO);
}
```

### 4.2 Token 存储（前端）

**保存 Token** (`stores/user.js`):

```javascript
const loginAction = async (loginData) => {
  const res = await login(loginData)
  if (res.code === 200 && res.data && res.data.token) {
    setToken(res.data.token)
    const userInfo = { ...res.data }
    delete userInfo.token
    setUserInfo(userInfo)
    return true
  }
  throw new Error(res.message || '登录失败')
}
```

**Token 存储位置**: `localStorage`

### 4.3 Token 验证（后端）

**拦截器验证 Token** (`config/AuthInterceptor.java`):

```java
@Override
public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {
    String token = request.getHeader("Authorization");
    
    if (token == null || !token.startsWith("Bearer ")) {
        // 未携带 Token，检查是否是公开接口
        return isPublicEndpoint(request);
    }
    
    token = token.substring(7); // 去掉 "Bearer " 前缀
    
    try {
        Claims claims = JwtUtil.parseToken(token);
        Long userId = Long.valueOf(claims.getSubject());
        Long roleId = claims.get("roleId", Long.class);
        
        // 将用户信息存储到 request 中
        request.setAttribute("userId", userId);
        request.setAttribute("roleId", roleId);
        
        return true;
    } catch (Exception e) {
        // Token 无效或过期
        response.setStatus(401);
        return false;
    }
}
```

### 4.4 Token 自动添加（前端）

**请求拦截器自动添加** (`utils/request.js`):

```javascript
request.interceptors.request.use(
  config => {
    const token = localStorage.getItem('token')
    if (token) {
      config.headers.Authorization = `Bearer ${token}`
    }
    return config
  }
)
```

### 4.5 Token 过期处理（前端）

**响应拦截器处理 401** (`utils/request.js`):

```javascript
request.interceptors.response.use(
  response => { /* ... */ },
  error => {
    if (error.response && error.response.status === 401) {
      ElMessage.error('未授权，请重新登录')
      localStorage.removeItem('token')
      localStorage.removeItem('userInfo')
      router.push('/login')
    }
    return Promise.reject(error)
  }
)
```

---

## 五、权限控制联动

### 5.1 权限数据流转

```
用户登录
  ↓
后端查询用户角色权限 (sys_role_permission + sys_permission)
  ↓
返回权限列表到前端 (UserDTO.permissions)
  ↓
前端保存到 userStore.userInfo.permissions
  ↓
前端使用 usePermission() 判断权限
  ↓
后端使用 @RequiresPermission 注解验证权限
```

### 5.2 后端权限控制

**权限注解** (`annotation/RequiresPermission.java`):

```java
@Target({ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface RequiresPermission {
    String[] value();
}
```

**权限切面** (`aspect/PermissionAspect.java`):

```java
@Aspect
@Component
public class PermissionAspect {
    
    @Around("@annotation(requiresPermission)")
    public Object around(ProceedingJoinPoint joinPoint, RequiresPermission requiresPermission) {
        HttpServletRequest request = getRequest();
        List<String> userPermissions = (List<String>) request.getAttribute("permissions");
        
        String[] requiredPermissions = requiresPermission.value();
        boolean hasPermission = false;
        
        for (String permission : requiredPermissions) {
            if (userPermissions != null && userPermissions.contains(permission)) {
                hasPermission = true;
                break;
            }
        }
        
        if (!hasPermission) {
            throw new RuntimeException("权限不足");
        }
        
        return joinPoint.proceed();
    }
}
```

**权限拦截器** (`config/AuthInterceptor.java`):

```java
// 在拦截器中查询用户权限并存储到 request
List<SysPermission> permissions = permissionService.getPermissionsByRoleId(roleId);
List<String> permissionCodes = permissions.stream()
    .map(SysPermission::getPermissionCode)
    .collect(Collectors.toList());
request.setAttribute("permissions", permissionCodes);
```

**接口使用权限注解**:

```java
@GetMapping("/page")
@RequiresPermission({"system:user:view"})
public Result<Page<SysUser>> getPage(...) {
    // ...
}

@PostMapping
@RequiresPermission({"system:user:add"})
public Result<Boolean> saveUser(...) {
    // ...
}
```

### 5.3 前端权限控制

**权限判断工具** (`composables/usePermission.js`):

```javascript
import { useUserStore } from '@/stores/user'

export const usePermission = () => {
  const userStore = useUserStore()
  
  const hasPermission = (permissionCode) => {
    const permissions = userStore.userInfo?.permissions || []
    return permissions.includes(permissionCode)
  }
  
  return { hasPermission }
}
```

**组件中使用权限控制**:

```vue
<script setup>
import { usePermission } from '@/composables/usePermission'

const { hasPermission } = usePermission()
</script>

<template>
  <!-- 按钮权限控制 -->
  <el-button v-if="hasPermission('plan:add')" @click="handleAdd">
    新增计划
  </el-button>
  
  <el-button v-if="hasPermission('plan:edit')" @click="handleEdit">
    编辑
  </el-button>
  
  <el-button v-if="hasPermission('plan:delete')" @click="handleDelete">
    删除
  </el-button>
</template>
```

**权限代码必须一致**:

- 前端: `hasPermission('system:user:view')`
- 后端: `@RequiresPermission({"system:user:view"})`
- 数据库: `sys_permission.permission_code = 'system:user:view'`

---

## 六、数据格式对接

### 6.1 分页数据格式

**后端分页对象** (MyBatis Plus `Page<T>`):

```java
Page<SysUser> page = new Page<>(current, size);
// 查询后
page.getRecords()  // 数据列表
page.getTotal()    // 总记录数
page.getCurrent()  // 当前页
page.getSize()     // 每页大小
```

**前端接收格式**:

```json
{
  "code": 200,
  "message": "操作成功",
  "data": {
    "records": [...],
    "total": 100,
    "current": 1,
    "size": 10,
    "pages": 10
  }
}
```

**前端使用**:

```javascript
const res = await getUserList({ current: 1, size: 10 })
const pageData = res.data
const userList = pageData.records    // 列表数据
const total = pageData.total         // 总记录数
```

### 6.2 日期时间格式

**后端日期类型**: `LocalDateTime` (Java)

**序列化配置**:

```java
@JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
private LocalDateTime createTime;
```

**前端接收格式**: `"2024-01-01 12:00:00"` (字符串)

**前端格式化工具** (`utils/date.js`):

```javascript
export const formatDateTime = (dateTimeStr) => {
  if (!dateTimeStr) return ''
  const date = new Date(dateTimeStr)
  return date.toLocaleString('zh-CN', {
    year: 'numeric',
    month: '2-digit',
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit'
  })
}
```

### 6.3 文件上传格式

**前端文件上传** (`api/user.js`):

```javascript
export const uploadAvatar = (formData) => {
  return request({
    url: '/upload/avatar',
    method: 'post',
    data: formData,
    headers: {
      'Content-Type': 'multipart/form-data'
    }
  })
}
```

**前端使用**:

```javascript
const fileInput = document.querySelector('input[type="file"]')
const file = fileInput.files[0]
const formData = new FormData()
formData.append('file', file)

const res = await uploadAvatar(formData)
if (res.code === 200) {
  const fileUrl = res.data.fileUrl
  // 使用文件 URL
}
```

**后端文件上传** (`FileUploadController.java`):

```java
@PostMapping("/avatar")
public Result<Map<String, String>> uploadAvatar(@RequestParam("file") MultipartFile file) {
    String fileName = fileUploadService.uploadAvatar(file);
    Map<String, String> result = new HashMap<>();
    result.put("fileUrl", "/uploads/avatar/" + fileName);
    return Result.success(result);
}
```

**后端响应格式**:

```json
{
  "code": 200,
  "message": "上传成功",
  "data": {
    "fileUrl": "/uploads/avatar/2024/01/01/xxx.jpg"
  }
}
```

---

## 七、错误处理联动

### 7.1 后端错误处理

**统一异常处理** (可以通过 `@ControllerAdvice` 实现):

```java
@ControllerAdvice
public class GlobalExceptionHandler {
    
    @ExceptionHandler(Exception.class)
    @ResponseBody
    public Result<?> handleException(Exception e) {
        return Result.error(e.getMessage());
    }
}
```

**业务异常抛出**:

```java
if (user == null) {
    throw new RuntimeException("用户不存在");
}
```

### 7.2 前端错误处理

**响应拦截器统一处理** (`utils/request.js`):

```javascript
request.interceptors.response.use(
  response => {
    const res = response.data
    if (res.code === 200) {
      return res
    } else {
      // 业务错误
      ElMessage.error(res.message || '请求失败')
      return Promise.reject(new Error(res.message || '请求失败'))
    }
  },
  error => {
    // HTTP 错误
    if (error.response) {
      switch (error.response.status) {
        case 401:
          ElMessage.error('未授权，请重新登录')
          localStorage.removeItem('token')
          router.push('/login')
          break
        case 403:
          ElMessage.error('拒绝访问')
          break
        case 404:
          ElMessage.error('请求错误，未找到该资源')
          break
        case 500:
          ElMessage.error('服务器错误')
          break
        default:
          ElMessage.error(error.response.data?.message || '网络错误')
      }
    } else {
      ElMessage.error('网络连接失败')
    }
    return Promise.reject(error)
  }
)
```

**业务中使用**:

```javascript
try {
  const res = await saveUser(userData)
  if (res.code === 200) {
    ElMessage.success('保存成功')
  }
} catch (error) {
  // 错误已在拦截器中处理，这里可以做额外处理
  console.error('保存失败:', error)
}
```

---

## 八、状态管理联动

### 8.1 用户状态管理

**Pinia Store** (`stores/user.js`):

```javascript
import { defineStore } from 'pinia'
import { ref } from 'vue'
import { login, getCurrentUser } from '@/api/user'

export const useUserStore = defineStore('user', () => {
  const token = ref(localStorage.getItem('token') || '')
  const userInfo = ref(JSON.parse(localStorage.getItem('userInfo') || 'null'))

  const loginAction = async (loginData) => {
    const res = await login(loginData)
    if (res.code === 200 && res.data?.token) {
      setToken(res.data.token)
      const userInfo = { ...res.data }
      delete userInfo.token
      setUserInfo(userInfo)
      return true
    }
    throw new Error(res.message || '登录失败')
  }

  const fetchUserInfo = async () => {
    const res = await getCurrentUser()
    if (res.code === 200) {
      setUserInfo(res.data)
    }
  }

  const logout = () => {
    token.value = ''
    userInfo.value = null
    localStorage.removeItem('token')
    localStorage.removeItem('userInfo')
  }

  return {
    token,
    userInfo,
    loginAction,
    fetchUserInfo,
    logout
  }
})
```

### 8.2 权限状态使用

**组件中使用**:

```vue
<script setup>
import { useUserStore } from '@/stores/user'
import { usePermission } from '@/composables/usePermission'

const userStore = useUserStore()
const { hasPermission } = usePermission()

// 获取用户信息
const userInfo = userStore.userInfo
const username = userInfo?.username
const roleName = userInfo?.roleName
</script>

<template>
  <div>
    <p>欢迎，{{ username }}</p>
    <p>角色：{{ roleName }}</p>
    
    <el-button v-if="hasPermission('user:add')">
      新增用户
    </el-button>
  </div>
</template>
```

---

## 九、路由与权限联动

### 9.1 路由守卫

**路由配置** (`router/index.js`):

```javascript
import { createRouter, createWebHistory } from 'vue-router'
import { useUserStore } from '@/stores/user'

const router = createRouter({
  history: createWebHistory(),
  routes: [
    {
      path: '/login',
      name: 'Login',
      component: () => import('@/views/Login.vue'),
      meta: { requiresAuth: false }
    },
    {
      path: '/user',
      name: 'UserList',
      component: () => import('@/views/user/UserList.vue'),
      meta: { 
        requiresAuth: true,
        permissions: ['system:user:view']
      }
    }
  ]
})

router.beforeEach((to, from, next) => {
  const userStore = useUserStore()
  const token = userStore.token

  if (to.path === '/login') {
    if (token) {
      next('/dashboard')
    } else {
      next()
    }
  } else {
    if (!token) {
      next('/login')
    } else {
      // 权限验证
      if (to.meta.permissions) {
        const { hasPermission } = usePermission()
        const hasAnyPermission = to.meta.permissions.some(permission => 
          hasPermission(permission)
        )
        if (!hasAnyPermission) {
          ElMessage.warning('您没有权限访问该页面')
          next('/dashboard')
          return
        }
      }
      next()
    }
  }
})

export default router
```

---

## 十、典型联动场景

### 10.1 用户登录流程

```
1. 用户在登录页面输入账号密码
   ↓
2. 前端调用 login API
   POST /api/user/login
   { username: 'admin', password: '123456' }
   ↓
3. 后端验证账号密码
   ↓
4. 后端生成 JWT Token
   ↓
5. 后端查询用户权限列表
   ↓
6. 后端返回 UserDTO（包含 token 和 permissions）
   {
     code: 200,
     data: {
       token: 'xxx',
       userId: 1,
       permissions: ['system:user:view', ...]
     }
   }
   ↓
7. 前端保存 token 到 localStorage
   ↓
8. 前端保存用户信息到 userStore
   ↓
9. 前端跳转到 Dashboard
```

### 10.2 查询用户列表流程

```
1. 用户在用户列表页面
   ↓
2. 前端调用 getUserList API
   GET /api/user/page?current=1&size=10
   Headers: Authorization: Bearer <token>
   ↓
3. 后端 AuthInterceptor 拦截请求
   ↓
4. 后端验证 Token 并解析用户信息
   ↓
5. 后端 PermissionAspect 检查权限
   @RequiresPermission({"system:user:view"})
   ↓
6. 后端查询数据库获取用户列表
   ↓
7. 后端返回分页数据
   {
     code: 200,
     data: {
       records: [...],
       total: 100
     }
   }
   ↓
8. 前端接收数据并渲染到页面
```

### 10.3 新增用户流程

```
1. 用户点击"新增用户"按钮
   （前端已通过 hasPermission('system:user:add') 控制显示）
   ↓
2. 用户填写表单并提交
   ↓
3. 前端调用 saveUser API
   POST /api/user
   Headers: Authorization: Bearer <token>
   Body: { username: 'xxx', ... }
   ↓
4. 后端 AuthInterceptor 验证 Token
   ↓
5. 后端 PermissionAspect 检查权限
   @RequiresPermission({"system:user:add"})
   ↓
6. 后端验证数据（Spring Validation）
   ↓
7. 后端保存用户到数据库
   ↓
8. 后端返回结果
   { code: 200, message: '新增成功' }
   ↓
9. 前端显示成功提示并刷新列表
```

---

## 十一、最佳实践

### 11.1 API 接口命名

- **RESTful 风格**: 使用标准的 HTTP 方法
  - GET: 查询
  - POST: 新增
  - PUT: 更新
  - DELETE: 删除

- **URL 设计**:
  - `/api/user` - 用户资源
  - `/api/user/{id}` - 特定用户
  - `/api/user/page` - 分页查询

### 11.2 错误处理

- **前端**: 统一在响应拦截器中处理错误
- **后端**: 统一返回 `Result<T>` 格式
- **错误消息**: 提供友好的错误提示

### 11.3 权限控制

- **双重验证**: 前端控制 UI 显示，后端保证安全性
- **权限代码统一**: 前后端使用相同的权限代码
- **细粒度控制**: 支持按钮级权限控制

### 11.4 数据格式

- **统一响应格式**: 使用 `Result<T>` 包装所有响应
- **日期格式**: 统一使用 `yyyy-MM-dd HH:mm:ss`
- **分页格式**: 统一使用 MyBatis Plus 的 `Page<T>`

### 11.5 代码组织

- **前端**: API 接口统一放在 `src/api/` 目录
- **后端**: 控制器统一放在 `controller` 包
- **命名规范**: 前后端保持一致的命名风格

---

## 十二、常见问题

### 12.1 跨域问题

**问题**: 前端请求后端接口时出现跨域错误

**解决方案**:
1. 开发环境: 使用 Vite 代理配置
2. 生产环境: 在后端配置 CORS 或使用 Nginx 反向代理

### 12.2 Token 过期

**问题**: Token 过期后如何自动刷新

**解决方案**:
1. 前端在响应拦截器中检测 401 错误
2. 清除本地 Token 并跳转登录页
3. 或者实现 Token 刷新机制

### 12.3 权限不一致

**问题**: 前端显示的按钮，后端却返回 403

**解决方案**:
1. 确保前后端使用相同的权限代码
2. 权限变更后，用户需要重新登录获取最新权限
3. 或者实现权限刷新接口

### 12.4 数据格式不匹配

**问题**: 前后端数据格式不一致导致解析错误

**解决方案**:
1. 统一使用 JSON 格式
2. 后端统一使用 `Result<T>` 包装响应
3. 前端统一在响应拦截器中解析

---

## 十三、参考资料

- [Vue 3 官方文档](https://cn.vuejs.org/)
- [Spring Boot 官方文档](https://spring.io/projects/spring-boot)
- [Axios 官方文档](https://axios-http.com/)
- [JWT 官方文档](https://jwt.io/)
- [MyBatis Plus 官方文档](https://baomidou.com/)

---

*文档更新时间: 2024年*

